/* *****************************************************************************
 *  Name:
 *  Date:
 *  Description:根据Timeing检测，需要把sap写成实例变量
 *  参考 https://blog.csdn.net/YunHsiao/article/details/50405328 增加了实例变量nounID 和 nouns，通过增加空间来减少时间
 **************************************************************************** */

import edu.princeton.cs.algs4.Digraph;
import edu.princeton.cs.algs4.In;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;

public class WordNet {
    private ArrayList<String[]> synArray;       // 通过序号（ArrayList index），检索同义词集合（String[])
    private HashMap<String, ArrayList<Integer>> nounID;     // 通过名词(String Key),搜索序号
    private HashSet<String> nouns;      // 所有名词的集合
    private SAP sap;        // 寻找最近的公共祖先

    // constructor takes the name of the two input files
    public WordNet(String synsets, String hypernyms) {

        if (synsets == null || hypernyms == null) throw new IllegalArgumentException();

        In in1 = new In(synsets);
        String synLine = in1.readLine();
        // read synset

        synArray = new ArrayList<String[]>();
        nounID = new HashMap<String, ArrayList<Integer>>();

        // 创建 synArray
        String aux;
        while (synLine != null) {
            aux = synLine.split(",")[1];    // 同义词集合，每个noun用空格隔开
            synArray.add(aux.split(" "));       // synArray的每一个元素都是某行所有同义词的String数组（可以指向不同大小的数组呀？）
            synLine = in1.readLine();     // 如果到底了，是会被赋值null的吧……？

        }
        // Use the readLine() method in our In library to read in the data one line at a time. Use the split() method in Java's String library to divide a line into fields. You can find an example using split() in Domain.java. Use Integer.parseInt() to convert string id numbers into integers.
        // Do I need to store the glosses? No, you won't use them on this assignment.

        // 感觉不能直接用文件作参数调用digraph的构造函数=-=，输入文件格式跟那个不同啊。

        // 创建sap
        Digraph hypDigraph = new Digraph(synArray.size());
        // Boolean[] notRoot = new Boolean[synArray.size()];       // boolean的缺省值是flase
        In in2 = new In(hypernyms);
        String hypLine = in2.readLine();
        int ver;        // 每一行的第一个数
        while (hypLine != null) {
            ver = Integer.parseInt(hypLine.split(",")[0]);
            //  notRoot[ver] = true;
            for (String s : hypLine.split(","))
                if (Integer.parseInt(s) != ver)     // 去掉对本身的Edge添加
                    hypDigraph.addEdge(ver, Integer.parseInt(s));
            hypLine = in2.readLine();
        }
        //    int rootNumber = 0;
        //  for (boolean b : notRoot) {
        //       if (b == false) rootNumber++;

        //    }

        //    if (rootNumber == 0 || rootNumber > 1) throw new IllegalArgumentException();

        sap = new SAP(hypDigraph);

        // 创建nouns

        nouns = new HashSet<String>();

        for (String[] line : synArray) {
            for (String s : line)
                nouns.add(s);
        }

        // 创建nounID

        for (String s : nouns) {
            nounID.put(s, findSynset(s));
        }

    }


    private ArrayList<Integer> findSynset(String noun) {
        ArrayList<Integer> synNumber = new ArrayList<Integer>();        // 一个noun可能出现在多行，所以返回了一个集合
        for (String[] line : synArray)
            for (String s : line)
                if (s.equals(noun)) synNumber.add(synArray.indexOf(line));
        return synNumber;
    }

    // returns all WordNet nouns
    public Iterable<String> nouns() {
        // Queue<String> nouns = new Queue<String>();

        return nouns;
    }

    // is the word a WordNet noun?
    public boolean isNoun(String word) {
        if (word == null) throw new IllegalArgumentException();
        return nouns.contains(word);
    }

    // distance between nounA and nounB (defined below)
    public int distance(String nounA, String nounB) {
        if (nounA == null || nounB == null) throw new IllegalArgumentException();
        if (!isNoun(nounA) || !isNoun(nounB)) throw new IllegalArgumentException();

        return sap.length(nounID.get(nounA), nounID.get(nounB));
    }


    // a synset (second field of synsets.txt) that is the common ancestor of nounA and nounB
    // in a shortest ancestral path (defined below)
    public String sap(String nounA, String nounB) {
        if (nounA == null || nounB == null) throw new IllegalArgumentException();
        if (!isNoun(nounA) || !isNoun(nounB)) throw new IllegalArgumentException();


        int synNumber = sap
                .ancestor(nounID.get(nounA), nounID.get(nounB));     // 目标synset在数组中的索引，即行号

        StringBuilder ancestor = new StringBuilder();
        for (String s : synArray.get(synNumber))
            ancestor.append(s + " ");
        // ancestor = ancestor + " " + s;
        // Builds a 'String' object using the '+' operator in a loop, which can take time quadratic in the length of the resulting string.
        // Instead, use 'StringBuilder'.

        return ancestor.toString();
    }


    // do unit testing of this class
    public static void main(String[] args) {

    }
}
