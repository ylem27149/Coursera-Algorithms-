/* *****************************************************************************
 *  Name:
 *  Date:
 *  Description:ArrayIndex outofBoundary 的 bug 第一遍很难发现啊（抱头）
 *  compareChar之中初始化被比较的字母数组的时候错误的写了双层for，会导致每个元素都被初始化成最后一个序列对应的值
 *  说起来，每一个元素都一样那种极端情况，我没有处理。所以对m应该限制一下小于length，嗯。corner test没提到，先不写吧。
 **************************************************************************** */

import edu.princeton.cs.algs4.StdIn;
import edu.princeton.cs.algs4.StdOut;

import java.util.ArrayList;
import java.util.Arrays;

public class CircularSuffixArray {

    private int length;
    private char[] firstChar;       // the first character in the original circular suffix
    private int[] index;
    // the index of the original suffix that appears ith in the sorted array


    // circular suffix array of s
    public CircularSuffixArray(String s) {
        if (s == null) throw new IllegalArgumentException();
        length = s.length();
        index = new int[s.length()];
        firstChar = s.toCharArray();
        ArrayList<Integer> firstCharIndex = new ArrayList<Integer>();
        for (int i = 0; i < s.length(); i++)
            firstCharIndex.add(i);
        compareChar(firstCharIndex, 0, 0);
        /***
         char[] sortedChar = firstChar.clone();
         Arrays.sort(sortedChar);
         ArrayList<Character> nextChar = new ArrayList<Character>();
         for (int i = 0; i < s.length(); i++)
         for (int j = 0; j < s.length(); j++) {
         if (sortedChar[i] == firstChar[j] && sortedChar[i] == sortedChar[i + 1])
         nextChar.add(firstChar[j + 1]);
         if (sortedChar[i] == firstChar[j] && sortedChar[i] != sortedChar[i + 1])
         index[i] = j;
         }
         ***/
        // if firstChar 相同，再去比下一个字母。
        // if (sortedChar[i] == sortedChar[i + 1])

    }

    private void compareChar(ArrayList<Integer> firstCharIndex, int m, int s)
    //  firstCharIndex is the fisrt character index in original circular suffix
    // this function is used to compare mth character in those circular suffix
    // s is the start index of the same Suffix substrings in sorted array
    {
        ArrayList<Integer> next = new ArrayList<Integer>();
        char[] sort = new char[firstCharIndex.size()];
        for (int i = 0; i < sort.length; i++)
            if (firstCharIndex.get(i) + m < length)
                sort[i] = firstChar[firstCharIndex.get(i) + m];
            else sort[i] = firstChar[firstCharIndex.get(i) + m - length
                    + 1];   // if f+m out of boundary

        // 其实也可以写一个被比较字母的数组，ith字母对应firstCharIndex 中ith 的字符串首字母。
        Arrays.sort(sort);

        for (
                int i = 0;
                i < sort.length; i++) {
            if (i == 0 || sort[i] != sort[i - 1])
                for (int f : firstCharIndex) {
                    if ((f + m < length && sort[i] == firstChar[f + m]) || (f + m >= length
                            && sort[i] == firstChar[f + m - length + 1])) {
                        if (i < sort.length - 1 && sort[i] == sort[i + 1])
                            next.add(f);
                        else
                            index[i + s] = f;   // 其实这里可以接个break/continue。结束在f中的查找。唔不过好像提升不大，不说了。
                    }
                }
            if (next.size() != 0) {
                compareChar(next, m + 1, i + s);
                next = new ArrayList<Integer>();
            }

        }

    }


    /***
     // A natural approach is to define a nested class CircularSuffix that represents a circular suffix implicitly
     // (via a reference to the input string and a pointer to the first character in the circular suffix).
     // You might also consider making CircularSuffix implement the Comparable<CircularSuffix> interface.
     // Note, that while this is, perhaps, the cleanest solution, it is not the fastest.
     private class CircularSuffix {
     // 这个的意思是，每个内部类代表一行吗。这样可比较倒是能理解了。
     private String s;
     private char[] firstChar;       // the first character in the original circular suffix
     private int[] index;            // the index of the original suffix that appears ith in the sorted array

     public CircularSuffix(String s) {
     this.s = s;
     index = new int[s.length()];
     firstChar = s.toCharArray();
     char[] sortedChar = firstChar.clone();
     Arrays.sort(sortedChar);
     for (int i = 0; i < s.length(); i++)
     for (int j = 0; j < s.length(); j++)
     if (firstChar[i] == sortedChar[j])
     index[i] = sortedChar[j];   // if firstChar 相同，再去比下一个字母。

     }

     public int Index(int i) {
     return index[i];
     }
     }
     ***/
    // length of s
    public int length() {
        return length;
    }

    // returns index of ith sorted suffix
    public int index(int i) {
        if (i < 0 || i >= length)
            throw new IllegalArgumentException();
        return index[i];
    }

    // unit testing (required)
    public static void main(String[] args) {
        CircularSuffixArray test = new CircularSuffixArray(StdIn.readString());
        for (int i = 0; i < test.length(); i++)
            StdOut.println("index" + i + " = " + test.index(i));

    }

}
