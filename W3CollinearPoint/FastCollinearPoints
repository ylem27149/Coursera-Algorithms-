/* *****************************************************************************
 *  Name:
 *  Date:
 *  Description:去掉了ArrayList的调用。
 *  修改了segment()，避免返回的线段数组中会有Null
 *  在colliearFinder 的  while (slope == origin.slopeTo(slopeSoredPoints[last])) 循环，增加了对last的边界检测，以免最后一个元素符合条件时，last继续递增使得超出数组界限
 *  发现这种边界超出界限的bug，写几个printf显示关键参数变化轨迹，再手算模拟以下就很好debug了（其实就是C编译器的单步运行看参数变化，我猜这个应该内建也有这种功能？不过没找到，就先这样吧）
 **************************************************************************** */

import edu.princeton.cs.algs4.In;
import edu.princeton.cs.algs4.StdDraw;
import edu.princeton.cs.algs4.StdOut;

import java.util.Arrays;

public class FastCollinearPoints {
    private int numOfSeg;       // 有四个点的线段条数
    private LineSegment[] lines;    // 有四个点的线段集合


    public FastCollinearPoints(
            Point[] points)     // finds all line segments containing 4 or more points
    {
        numOfSeg = 0;
        lines = new LineSegment[2];

        //已经在class开头声明过变量类型，这里左边就不用写类型了

        cornerTest(points);       // 输入的边界测试
        Point[] sortedPoints = points.clone();
        Arrays.sort(sortedPoints);        // sortedPoints按点的大小从小到大排序


        for (int i = 0; i < sortedPoints.length; i++)
            colliearFinder(sortedPoints, sortedPoints[i]);
        // 每个点从小到大，一个一个作为计算斜率排序的固定端点，寻找四点共线的所有可能
        // 每次排序时，并不去除已经排过的点。所以可以直接扫到结尾（应该会有一点冗余，懒得细想了
        // 因为没有排除已经用过的端点，所以不会有线段子集出现。
        // 只有当固定端点为一组共线点中的最小点时，这个线段才会输出，这样就保证了不会重复输出同一条线。
        // 不过这样感觉性能会受点影响，因为计算了所有共线点的全排列。
        // 因为每次都会用按点大小排序的母本进行重新排序，如果Arrays.sort是稳定的话（网上说当参数是对象时是稳定的），输出时，线段最大点肯定 是最后一个等斜率点。

    }

    private void colliearFinder(Point[] points, Point origin) {
        // 以Origin点为斜率计算的端点，将数组排序，找出其中所有共线点

        Point[] slopeSoredPoints = points.clone();
        Arrays.sort(slopeSoredPoints, origin.slopeOrder());     // 按斜率排序

        double slope;
        int last = 1;
        int collinearNum = 2;

        while (last < slopeSoredPoints.length - 1) {

            // 初始化斜率，寻找共线点
            slope = origin.slopeTo(slopeSoredPoints[last]);
            collinearNum = 2;
            last++;


            while (slope == origin.slopeTo(slopeSoredPoints[last])) {
                collinearNum++;
                if (last < slopeSoredPoints.length - 1)
                    last++;
                else break;
            }
            // 退出循环的时候，last所指向的，是第一个不同斜率的点

            if (collinearNum >= 4)       // 判断是否为某类的子类,如果是子类，就无事发生，如果不是子类就加入lineSegment。
            {
                Point[] copy = new Point[collinearNum];
                copy[0] = origin;
                for (int i = 1; i < collinearNum; i++)
                    copy[i] = slopeSoredPoints[last - collinearNum
                            + i];
                // clone 不接受参数，不知道数组有没有内建的复制一部分的方法，就干脆自己写了，也不麻烦

                Arrays.sort(copy);
                // Math.min 只接受原始类型的参数，所以就排序来间接实现比大小。我记得书上也都是这么实现的。

                if (copy[0].compareTo(origin) == 0) {
                    lines[numOfSeg] = new LineSegment(origin, slopeSoredPoints[last - 1]);
                    numOfSeg++;
                    if (numOfSeg == lines.length) resize(2 * lines.length);
                }
            }

        }


    }

    private void resize(int max) {
        LineSegment[] temp = new LineSegment[max];
        for (int i = 0; i < numOfSeg; i++)
            temp[i] = lines[i];
        lines = temp;
    }

    // Corner cases. Throw a java.lang.IllegalArgumentException if the argument to the constructor is null,
    // if any point in the array is null, or if the argument to the constructor contains a repeated point.
    private void cornerTest(Point[] sortedPointss) {

        if (sortedPointss == null)
            throw new IllegalArgumentException();
        int N = sortedPointss.length;
        if (N > 1) {
            for (int i = 0; i < N - 1; i++)
                if (sortedPointss[i] == null
                        || sortedPointss[i].compareTo(sortedPointss[i + 1]) == 0)
                    // 第二个式子，不能直接用 == 比两个对象的值是否相等，equals也没有重载，所以只能用compareTo是否为0来判断
                    // 传入的是已经排序过的数组，所以只要比附近的就行
                    throw new IllegalArgumentException();

            if (sortedPointss[N - 1] == null)
                throw new IllegalArgumentException();
        }
    }
    // How do I sort a subarray in Java? Arrays.sort(a, lo, hi) sorts the subarray from a[lo] to a[hi-1] according to the natural order of a[].
    // You can use a Comparator as the fourth argument to sort according to an alternate order.

    public int numberOfSegments()        // the number of line segments
    {
        return numOfSeg;
    }

    public LineSegment[] segments()                // the line segments
    {
        LineSegment[] lineSegment = new LineSegment[numOfSeg];
        for (int i = 0; i < numOfSeg; i++)
            lineSegment[i] = lines[i];
        return lineSegment;
    }

    public static void main(String[] args) {
        // read the n points from a file
        In in = new In(args[0]);
        int n = in.readInt();
        Point[] points = new Point[n];
        for (int i = 0; i < n; i++) {
            int x = in.readInt();
            int y = in.readInt();
            points[i] = new Point(x, y);
        }

        // draw the points
        StdDraw.enableDoubleBuffering();
        StdDraw.setXscale(0, 32768);
        StdDraw.setYscale(0, 32768);
        for (Point p : points) {
            p.draw();
        }
        StdDraw.show();

        // print and draw the line segments
        FastCollinearPoints collinear = new FastCollinearPoints(points);
        for (LineSegment segment : collinear.segments()) {
            StdOut.println(segment);
            segment.draw();
        }

        StdDraw.show();

    }
}

